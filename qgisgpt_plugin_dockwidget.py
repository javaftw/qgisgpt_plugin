# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QGISGPTPluginDockWidget
                                 A QGIS plugin
 QGISGPTPlugin harnesses the power of ChatGPT to interpret natural language commands within QGIS. Simply describe your GIS tasks in natural language and let QGISGPT generate the Python code to execute them.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-10-31
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Hennie Kotze
        email                : qgisgpt@xaisim.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import json
import re
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from PyQt5.QtCore import QTimer, QEvent, Qt
from qgis.core import QgsProject, QgsVectorLayer, QgsRasterLayer
from qgis.utils import iface
from .QGISGPT import QGISGPT
from .Utils import Utils

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'qgisgpt_plugin_dockwidget_base.ui'))

class QGISGPTPluginDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()
    lastSelectedLayer = "None"
    pythonConsoleTriggered = False
    
    def __init__(self, parent=None):
        """Constructor."""
        super(QGISGPTPluginDockWidget, self).__init__(parent)
        self.setupUi(self)
        self.utils = Utils()
        self.set_layer_names_for_combo_box()
        self.qgisgpt = QGISGPT()
        self.qgisgpt.responseReceived.connect(self.handleResponse)
        self.submitButton.clicked.connect(self.submitButton_clicked)
        self.executeButton.clicked.connect(self.executeButton_clicked)
        self.outputClearButton.clicked.connect(self.clearOutputText)
        self.layerNamesComboBox.currentIndexChanged.connect(self.onLayerSelectionChanged)
        # Install event filter
        self.inputText.installEventFilter(self)
        # Load and display the README.html file
        readme_path = os.path.join(os.path.dirname(__file__), 'README.html')
        if os.path.exists(readme_path):
            with open(readme_path, 'r', encoding='utf-8') as file:
                readme_html = file.read()
                self.textBrowserReadme.setHtml(readme_html)
    def onLayerSelectionChanged(self):
        self.lastSelectedLayer = self.layerNamesComboBox.currentText()
        
    def set_layer_names_for_combo_box(self):
        self.layerNamesComboBox.clear()
        layerNames = ["None"] + self.utils.get_layer_names_for_combobox()
        self.layerNamesComboBox.addItems(layerNames)
        if self.lastSelectedLayer in layerNames:
            index = layerNames.index(self.lastSelectedLayer)
        else:
            index = 0  # Default to "None"
        self.layerNamesComboBox.setCurrentIndex(index)

    def eventFilter(self, source, event):
        # Check if the event is a key press on inputText
        if source == self.inputText and event.type() == QEvent.KeyPress:
            if event.key() == Qt.Key_Return and not event.modifiers():
                self.submitButton.click()
                return True
        return super().eventFilter(source, event)
    
    def submitButton_clicked(self):
        self.inputText.setDisabled(True)
        self.submitButton.setDisabled(True)
        self.outputText.setText("Processing...")
        user_input = self.inputText.toPlainText()  # QTextEdit for user input
        self.clearInputText()
        self.append_user_message(user_input)
        api_key_openai = self.APIKey_OpenAI.text() 
        self.qgisgpt.set_api_key(api_key_openai)  # Set the API key for the Xaisim instance
        project_snapshot = self.utils.create_project_snapshot()  # Get the current project snapshot
        # Start the send_message thread, the response will be handled by handleResponse
        current_layer_name = self.layerNamesComboBox.currentText()
        if current_layer_name != "None":
            prompt = f"{user_input}. The currently active layer is named '{current_layer_name}'."
        else:
            prompt = user_input
        self.qgisgpt.send_message(prompt, project_snapshot)

    def handleResponse(self, response):
        # This method will be called when the response is received
        self.outputText.setText("")
        self.append_chatgpt_response(response)
        # Re-enable UI elements
        self.inputText.setEnabled(True)
        self.submitButton.setEnabled(True)
        if self.autoExecCheckBox.isChecked():
            self.executeButton_clicked()

    def executeButton_clicked(self):
        if self.pythonConsoleTriggered is False:
            # Open the Python console
            iface.actionShowPythonDialog().trigger()
            self.pythonConsoleTriggered = True
        print("Running QGISGPT code...")
        code_to_execute = self.outputText.toPlainText()
        try:
            exec(code_to_execute)
        except Exception as e:
            # Display the error message in the outputText QTextEdit
            error_text = f"An error ({e}) occurred while executing the code: {code_to_execute}"
            self.outputText.setText(error_text)
        finally:
            self.set_layer_names_for_combo_box()
    
    def clearInputText(self):
        self.inputText.clear()

    def clearOutputText(self):
        self.outputText.clear()
    
    def getLayerNames(self):
        """Return a list of layer names in the current QGIS project."""
        layers = QgsProject.instance().mapLayers().values()
        return [layer.name() for layer in layers]

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def format_message(self, message):
        # Initialize an empty string to hold the formatted message
        formatted_message = ""
        # Extract and format Python code blocks
        while "```python" in message and "```" in message:
            # Split the message at the first occurrence of the code block
            before_code, rest = message.split("```python", 1)
            code, after_code = rest.split("```", 1)
            # Format the text before the code block
            formatted_before_code = self.format_text(before_code)
            # Format the python code
            formatted_code = self.format_code(code)
            # Update the message to process the remaining text after the code block
            message = after_code
            # Combine formatted parts
            formatted_message += formatted_before_code + formatted_code
        # Format any remaining text after the last code block
        formatted_message += self.format_text(message)
        return formatted_message

    def format_text(self, text):
        # Formatting text between double asterisks as bold
        while '**' in text:
            start = text.find('**')
            end = text.find('**', start+2)
            if start != -1 and end != -1:
                text = text[:start] + '<b>' + text[start+2:end] + '</b>' + text[end+2:]
            else:
                break
        # Format URLs as clickable links
        # This pattern attempts to exclude trailing punctuation such as .,;?!" and parentheses
        url_pattern = r'(http[s]?://[^\s,;?!")]+(\.[^\s,;?!")]+)*)'
        formatted_text = re.sub(url_pattern, r'<a href="\1">\1</a>', text)
        # Replace newline characters with HTML line breaks
        formatted_text = "<p>" + formatted_text.replace("\n", "</p><p>") + "</p>"
        return formatted_text

    def format_code(self, code):
        # Clean and format the python code for display
        clean_code = code.strip()  # Remove leading and trailing whitespace
        self.outputText.setText(clean_code)
        formatted_code = "<pre style='background-color: black; color: white;'>" + clean_code.replace("\n", "<br>") + "</pre>"
        return formatted_code

    def append_user_message(self, message):
        formatted_message = self.format_message(message)
        formatted_html = f"<b style='font-size: 10pt; background-color: #ccddcc;'>You:</b>{formatted_message}"
        self.textBrowser.append(formatted_html)

    def append_chatgpt_response(self, response):
        formatted_response = self.format_message(response)
        formatted_html = f"<b style='font-size: 10pt; background-color: #ccccdd;'>QGISGPT:</b>{formatted_response}"
        self.textBrowser.append(formatted_html)